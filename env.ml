open Expr

(*......................................................................
  Environments and values
*)

module type ENV = sig
  (* the type of environments *)
  type env

  exception EvalException

  exception EvalError of string

  (* the type of values (including closures) stored in
     environments *)
  type value = Val of expr | Closure of (expr * env)

  type evaluator = expr -> env -> value

  (* empty () -- Returns an empty environment *)
  val empty : unit -> env

  (* close expr env -- Returns a closure for `expr` and its `env` *)
  val close : expr -> env -> value

  (* lookup env varid -- Returns the value in the `env` for the
     `varid`, raising an `Eval_error` if not found *)
  val lookup : env -> varid -> value

  (* extend env varid loc -- Returns a new environment just like
     `env` except that it maps the variable `varid` to the `value`
     stored at `loc`. This allows later changing the value, an
     ability used in the evaluation of `letrec`. To make good on
     this, extending an environment needs to preserve the previous
     bindings in a physical, not just structural, way. *)
  val extend : env -> varid -> value ref -> env

  (* env_to_string env -- Returns a printable string representation
     of environment `env` *)
  val env_to_string : env -> string

  (* value_to_string ?printenvp value -- Returns a printable string
     representation of a value; the optional flag `printenvp`
     (default: `true`) determines whether to include the environment
     in the string representation when called on a closure *)
  val value_to_string : ?printenvp:bool -> value -> string

  val err : string -> string -> string -> 'a
end

module Env : ENV = struct
  (* Exception for evaluator runtime, generated by an explicit `raise`
     construct in the object language *)
  exception EvalException

  (* Exception for evaluator runtime, generated by a runtime error in
     the interpreter *)
  exception EvalError of string

  (* Design - were it not for the rigid specification, I'd much prefer a
     key-value data structure for the environment (such as a Hashmap) instead
     of using a list. *)
  type env = (varid * value ref) list

  and value = Val of expr | Closure of (expr * env)

  type evaluator = expr -> env -> value

  let empty () : env = []

  let deep_copy_env (env : env) : env =
    List.map (fun (id, value) -> (id, ref !value)) env

  let close (exp : expr) (env : env) : value = Closure (exp, deep_copy_env env)

  let rec value_to_string ?(printenvp : bool = true) (v : value) : string =
    let get_closure_env (env : env) : string =
      if printenvp then env_to_string env else "...env"
    in
    match v with
    | Val exp -> "Val(" ^ Expr.exp_to_abstract_string exp ^ ")"
    | Closure (exp, env) ->
        "Closure("
        ^ Expr.exp_to_abstract_string exp
        ^ ", " ^ get_closure_env env ^ ")"

  and env_to_string (env : env) : string =
    let el_to_str ((name, loc) : varid * value ref) : string =
      "(" ^ name ^ ", ref -> " ^ value_to_string ~printenvp:false !loc ^ ")"
    in
    let add_el (acc : string) (el : varid * value ref) =
      acc ^ el_to_str el ^ ", "
    in
    List.fold_left add_el "[" env ^ "]"

  let rec extend (env : env) (varname : varid) (loc : value ref) : env =
    match env with
    | [] -> [ (varname, loc) ]
    | ((name, current_loc) as hd) :: tl ->
        if name = varname then (
          current_loc := !loc;
          env)
        else hd :: extend tl varname loc

  let lookup (env : env) (varname : varid) : value =
    let filter (id, _) = id = varname in
    try !(snd (List.find filter env))
    with
    | Not_found
    (* Obviously catching an error to throw a different one is
       undesirable, but this is to satisfy the signature specification *)
    ->
      raise
        (EvalError
           ("lookup: variable binding not found " ^ varname ^ " -| "
          ^ env_to_string env))

  let err (origin : string) (message : string) (context : string) : 'a =
    raise
      (EvalError
         (origin ^ ": " ^ message ^ " -- Exited with context: " ^ context))
end
